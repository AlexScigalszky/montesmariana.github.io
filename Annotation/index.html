<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="icon" href="favicon.ico" type="image/x-icon">

    <!-- Bootstrap CSS -->
    <link href="css/mytheme.min.css" rel="stylesheet" />
    <!-- <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"> -->
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <!-- FontAwesomeIcons -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.0/css/all.css" integrity="sha384-lZN37f5QGtY3VHgisS14W3ExzMWZxybE1SJSEsQp9S+oqd12jhcu+A56Ebc1zFSJ" crossorigin="anonymous">


    <title>Sense annotation</title>

    <style>

        #download {
            color : white;
        }

        .btn-cue {
            color : black;
            background : white;
            border-color : none;
        }

        .btn-cue:hover, .btn-cue:active, .btn-cue.active {
            color: white;
            background: #984ea3;
            border-color: #984ea3;
        }

        .btn-cue:active, .btn-cue.active {
            box-shadow: inset 0 0px
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="row justify-content-sm-center">
            <h1>Senses annotation</h1>
        </div>
        <div class="row justify-content-sm-end">
            <button type="button" class="btn shadow-sm btn-muted m-1"><a id="uploadfile">Upload progress</a></button>
            <button type="button" class="btn shadow-sm btn-primary m-1"><a id="download">Download</a></button>
        </div>
        <div class="row justify-content-sm-center" id="playground">
            <div class="col-sm-2" id="type_selection"></div>
            <div class="col-sm-10" id="concordance"></div>
        </div>
    </div>
</div>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!-- <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> -->
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
<!-- General d3 (version 4) release -->
<script src="https://d3js.org/d3.v4.min.js"></script>
<!-- Sweet alert (for nice alerts) -->
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@8"></script>

<script>
    var dropdown,
    text = {}, saved = JSON.stringify(text),
    users, this_user, names, achievements,
    definitions = {};

        // Upload a file

        d3.select("#uploadfile").on("click", function(){
            // abrir el dialog
            Swal.fire({
                title: 'Select your file',
                input: 'file',
                inputAttributes: {
                    accept: '*.json'
                }
            }).then((file) => {
                // al cargar el archivo
                if (file.value){
                    // si hay
                    var reader = new FileReader();
                    reader.onload = (e) => {
                        // al terminar de leer
                        uploaded_text = JSON.parse(reader.result);
                        if (uploaded_text['user'] == text['user']){ // if the uploaded file fits the current user
                            text = uploaded_text;
                            saved = JSON.stringify(text);
                            saveInLS();
                            start();
                            Swal.fire({
                                title: "File uploaded",
                                type: "success"
                            });
                        } else {
                            Swal.fire({
                                title: "Wrong file",
                                text: "Username doesn't match",
                                type: "error"
                            });
                        }
                    }
                    // leer el archivo
                    reader.readAsText(file.value);
                }
            });
        });

        // Download

        d3.select("#download").on("click", function(){
            saved = JSON.stringify(text);
            saveInLS();
            d3.select(this).attr("href", 'data:text/plain;charset=utf-8,' + encodeURIComponent(saved))
            .attr("download", text['user'] + ".json");
        });

        // Upload definitions
        d3.json("definitions.json", function(data) {
            definitions = data;
        });
        
        // Upload user's data
        d3.json("users.json", function(data) {
            users = data;
            names = d3.map(users, function(d) {return(d.name); }).keys();
            Swal.fire({
                title: "Welcome!",
                text: "Please enter your username",
                input: "text",
                inputPlaceholder: "mariana.montes",
                showCancelButton: true,
                inputValidator: (value) => { // only accept names included in users.json
                    if (names.indexOf(value) == -1) {
                        return "Invalid username, please try again."
                    }
                }
            }).then((result) => {
                if (result.value) {
                    Swal.fire({ // I don't know if this message is necessary
                        title: "Login succesful!",
                        type: "success",
                        confirmButtonText: "Let's start!"
                    });
                    text['user'] = result.value;
                    if (typeof(Storage) !== 'undefined' && JSON.parse(localStorage.getItem("annotations-" + text['user'])) != null) {
                        text = JSON.parse(localStorage.getItem("annotations-" + text['user']));
                    }
                    saved = JSON.stringify(text);
                    this_user = users.filter(function(d) {return(d.name == text['user'])})[0];
                    offerTypes(this_user);
                }
            });
        });

        // Create radio buttons with options of types, with first one as default choice
        function offerTypes(this_user) {
            var this_types = d3.keys(this_user['tokens']), // tailored to this user
            typesel;
            
            typesel = d3.select("#type_selection")
            typesel.append("h3").text("Types");
            typesel.append("div").attr("class", "btn-group-vertical btn-group-toggle")
            .attr("data-toggle", "buttons")
            .selectAll("label")
            .data(this_types)
            .enter()
            .append("label")
            .attr("class", "btn shadow-sm btn-success")
            .classed("active", function(d) {return (this_types.indexOf(d) == 0); })
            .text(function(d) {return(d); })
            .append("input")
            .attr("type", "radio")
            .attr("autocomplete", "off")
            .attr("name", "type")
            .attr("value", function(d) {return(d)});

            typesel.append("br");

            // React to changes in the radio buttons
            $(document).on("change", "input[name='type']", function(event) { 
                type = d3.select(this).property('value'); 
                start();
            });

            // Start with first type by default
            type = this_types[0];
            start();
        }

        // The main thing goes here
        function start() {

            // Remove and recreate concordance to avoid accumulation
            $("#concordance").remove();

            d3.select("#playground").append("div")
            .attr("class", "col-sm-10")
            .attr("id", "concordance");

            // Load the file of the corresponding type
            d3.tsv(type + ".tsv", function(data) {
                var concordances, // will be the subset for the user
                    toClassify = this_user['tokens'][type], viewing = 0, // to control what we see
                    workspace, tabs, overview, // spaces
                    sense_options, conc, annotations, inputtext, //annotations
                    conf, cues, reminder, legend, // sets to manipulate
                    buttons;

                // Filter the data
                concordances = data.filter(function(d) {return(toClassify.indexOf(d.id)>-1); });
                toClassify = d3.map(concordances, function(d) {return (d.id); }).keys();
                if (d3.keys(text).indexOf(type) == -1) {text[type] = {}; } // Create a dictionary within 'text' for this type
                
                // Select the senses for this type
                senses = definitions[type];
                senses.push({ // Add 'idk' option
                    'name' : "None",
                    'label' : "None of the above."
                })

                workspace = d3.select("#concordance");

                // Create tabs, with 'overview' selected by default
                tabs = workspace.append("ul")
                .attr("class", "nav nav-tabs")
                .attr("role", "tablist");

                tabs.selectAll("li")
                .data(["overview", "annotation"]).enter()
                .append("li")
                .attr("class", "nav-item")
                .append("a")
                .attr("class", "nav-link")
                .attr("id", function(d) {return(d + "-tab"); })
                .classed("active", function (d) {return (d == 'overview'); })
                .attr("data-toggle", "tab")
                .attr("href", function(d) {return("#" + d); })
                .attr("role", "tab")
                .attr("aria-controls", function(d) {return(d); })
                .text(function(d) {return(d.toUpperCase()); });

                workspace.append("div").attr("class", "tab-content")
                .selectAll("div")
                .data(["overview", "annotation"]).enter()
                .append("div")
                .attr("class", "tab-pane")
                .attr("id", function(d) {return(d); })
                .classed("active", function (d) {return (d == 'overview'); })
                .attr("width", "100vp")
                .attr("role", "tabpanel")
                .attr("aria-labelledby", function(d) {return(d + "-tab"); });

                // OVERVIEW TAB

                // Include legend of colors of the target word
                // legend = d3.select("#overview").append("div").attr("class", "row justify-content-sm-center mt-3");
                // legend.append("div").attr("class", "col-sm-auto px-3 m-1")
                //     .append("tex").style("color", '#b2182b').style("font-weight", "bold").text("Not annotated");
                // legend.append("div").attr("class", "col-sm-auto px-3 m-1")
                //     .append("span").style("color", '#ef8a62').style("font-weight", "bold").text("Partially annotated");
                // legend.append("div").attr("class", "col-sm-auto px-3 m-1")
                //     .append("span").style("color", '#2166ac').style("font-weight", "bold").text("Done!");
                
                // d3.select("#overview").append("hr");

                // Create scrollable space for concordances (also to separate from legend)
                overview = d3.select("#overview").append("div").attr("class", "mt-4").style("height", "70vh").style("overflow", "auto");

                // For each concordance we get a row, with a left, target and right column
                // 'target' column shows how far the progress is with colors and is clickable to take you to that occurrence
                overview.selectAll("div")
                .data(concordances).enter()
                .append("div").attr("class", "row no-gutters justify-content-sm-center")
                .each(function(d) {
                    var line = d3.select(this);

                    line.append("div").attr("class", "col-md-5")
                    .append("p").attr("class", "text-sm-right")
                    .text(function(d) {return (d.left); });

                    line.append("div").attr("class", "col-md-2 px-0")
                    .append("p").attr("class", "text-sm-center")
                    .style("font-weight", "bold")
                    .text(function(d) {return (d.target); })
                    .style('cursor', 'pointer')
                    .on("click", function(d) {
                        tabs.selectAll(".nav-link").classed("active", function() {
                            return(d3.select(this).attr("id") == "annotation-tab");
                        })
                        workspace.selectAll(".tab-pane").classed("active", function() {
                            return(d3.select(this).attr("id") == "annotation");
                        });
                        viewing = toClassify.indexOf(d.id);
                        displayConc();
                    });

                    updateTargetColor();

                    line.append("div").attr("class", "col-md-5")
                    .append("p").attr("class", "text-sm-left")
                    .text(function(d) {return (d.right); });
                });

                
                // SENSE ANNOTATION TAB

                // Store in the 'conc' variable the set of divs tied to the concordance, to which we'll add everything else
                conc = d3.select("#annotation").append("div").attr("class", "row justify-content-sm-center mt-5")
                .append("div").attr("class", "col-sm-12").selectAll("div")
                .data(concordances).enter()
                .append("div")
                        .attr("token_id", function(d) {return (d.id); }); // The 'token_id' attribute makes it available for nested elements

                displayConc(); // displays the concordance that corresponds to the current token

                /// ZERO SHOW concordance


                conc.append("p").html('<i class="fas fa-check-circle text-muted"></i>  Select a sense');

                conc.each(function(d) {
                    var line = d3.select(this);
                    line.append('blockquote')
                    .attr("class", "blockquote text-center")
                    .enter()
                    line.append("p")
                    .attr("class", "text-center")
                    .html(function(d) {return (d.left + '<span class="px-1 text-primary" style="font-weight:bold">' + d.target + '</span>' + d.right ); });
                });

                conc.append("hr");

                

                conc.append("div").attr("class", "row no-gutters justify-content-sm-center")
                .append("div").attr("class", "btn-group-vertical btn-group-toggle mt-2 btn-block")
                .attr("data-toggle", "buttons")
                .selectAll("label")
                .data(senses)
                .enter()
                .append("label")
                .attr("class", "btn shadow-md btn btn-outline-secondary btn-sm")
                .classed("active", function(d) {
                    var here = d3.select(this.parentNode.parentNode.parentNode).attr("token_id");
                    var chosen = is_annotated(here, type) && text[type][here]['sense'] == d.name;
                    return (chosen ? true : null);
                })
                .html(function(d) {return('<strong>' + d.name + "</strong> : " + d.label); })
                .append("input")
                .attr("type", "radio")
                .attr("autocomplete", "off")
                .attr("name", "sense")
                .attr("value", function(d) {return(d.name)});

                // Control de results when sense changes
                $(document).on('change', 'input[name="sense"]', function(event) {
                    var analized = d3.select(this.parentNode.parentNode.parentNode.parentNode).attr("token_id");
                    var answer = d3.select(this).attr('value');
                    // register data
                    text[type][analized] = {};
                    text[type][analized]['sense'] = answer;
                    text[type][analized]['cues'] = [];
                    
                    // enable further notes
                    cues.selectAll('.btn-group-toggle').attr('disabled', function(d) { // enable cues
                        return(is_annotated(d.id, type) ? null : true);
                    });
                    cues.selectAll('label').classed("active", function(d) {
                        var here = d3.select(this.parentNode.parentNode.parentNode.parentNode).attr('token_id');
                        var chosen = is_annotated(here, type) && text[type][here]['cues'].indexOf(d.index) > -1;
                        return (chosen ? true : null);
                    });
                    conf.attr("disabled", function(d) { // enable confidence buttons
                        return(is_annotated(d.id, type) ? null : true);
                    });
                    conc.selectAll('.form-control').attr('disabled', function(d) { // enable extra comments
                        return(is_annotated(d.id, type) ? null : true);
                    });
                    // none_reasons.style('display', function() {
                    //     var here = d3.select(this.parentNode).attr("token_id");
                    //     var chosen = d3.keys(text[type]).indexOf(here) > -1 && text[type][here]['sense'] == 'None of the others';
                    //     return (chosen ? 'block' : 'none');
                    // });

                    updateTargetColor();
                    displayReminder();
                    saveInLS();
                    AnnounceAchievement();
                    
                });

                

                // FOURTH we add the confidence radio buttons, although I WOULD like the star rating...

                conc.append("hr");
                conc.append("p").html('<i class="fas fa-check-circle text-muted"></i>  How confident are you?');

                conf = conc.append("div").attr("class", "row no-gutters justify-content-sm-center")
                .append("div").attr("id", "confidence")
                .attr("class", "btn-group-toggle")
                .attr("data-toggle", "buttons")
                .attr("disabled", function() {
                    var here = d3.select(this.parentNode.parentNode).attr("token_id");
                    return (is_annotated(here, type) ? null : true);
                });


                conf.append("span")
                // .style('font-weight', 'bold')
                .text("Not at all ");

                conf.selectAll("label")
                    .data([0, 1, 2, 3, 4, 5]).enter()
                        .append("label")
                        .attr("class", "btn btn-sm")
                        .style("font-size", "1.5em")
                        .html("&#x2605;")
                        .append("input").attr("type", "radio")
                        .attr("autocomplete", "off").attr("name", "confidence")
                        .attr("value", function(d) {return (d); });

                radiocolor();

                function radiocolor() {
                    conf.selectAll("label")
                        .style("color", function(d) {
                            var here = d3.select(this.parentNode.parentNode.parentNode).attr("token_id");
                            if (!is_annotated(here, type) ||
                            d3.keys(text[type][here]).indexOf('confidence') == -1 ||
                            text[type][here]['confidence'] < d) {
                                return ("#bdbdbd");
                            } else {
                                return ("#ffa500");
                            }
                        })
                }

                conf.append("span")
                .text(' Completely');

                // Control when confidence changes
                $(document).on('change', 'input[name="confidence"]', function(event) {
                    var analized = d3.select(this.parentNode.parentNode.parentNode.parentNode).attr("token_id");
                    var answer = d3.select(this).property('value');
                    text[type][analized]['confidence'] = answer;
                    updateTargetColor();
                    AnnounceAchievement();
                    radiocolor();
                });
// SECOND we show the concordance, in a variable called 'cues' because it's also clickable to register cues

                conc.append("hr");
                conc.append("p").html('<i class="fas fa-check-circle text-muted"></i>  Click on the words to select the cues');

                cues = conc.append("div").attr("class", "row no-gutters justify-content-center")
                    .each(function(d) {
                        var line = d3.select(this).append('p'),
                            left_context = [], 
                            right_context = [],
                            left_source = d.left.split(' '), 
                            right_source = d.right.split(' '); // turns the lines into lists of context words

                            // Each context word is represented by an 'index' (what gets registered), comprised of
                            // a letter ('L' for left, 'R' for right) and the distance to the target (starting with 1)
                            left_source.forEach(function(d) {
                                var cw_idx = left_source.length-left_source.indexOf(d)-1;
                                left_context.push({'index' : 'L'+cw_idx.toString(), 'cw' : d});
                            });
                            right_source.forEach(function(d) {
                                right_context.push({'index' : 'R'+right_source.indexOf(d).toString(), 'cw' : d});
                            });

                            halfLine(left_context, 'right');

                            line//.append("div").attr("class", "px-1")
                            .append("span").attr("class", "btn p-0 text-primary")
                            .style("font-weight", "bold")
                            // .style("color", "#1f77b4")
                            .text(function(d) {return (d.target); });

                            halfLine(right_context, 'left');

                            function halfLine(context, alignment) {
                                line
                                // .append("div")
                                // .attr("class", "text-md-" + alignment)
                                .append("span").attr("class", "btn-group-toggle")
                                .attr("data-toggle", "buttons")
                                .attr("disabled", function(d) {
                                    return(d3.keys(text[type]).indexOf(d.id) > -1 ? null : true);
                                })
                                .selectAll("label")
                                .data(context).enter()
                                .append("label").attr("class", "btn btn-cue px-1")
                                .classed("active", function(d) {
                                    var here = d3.select(this.parentNode.parentNode.parentNode.parentNode).attr('token_id');
                                    var chosen = is_annotated(here, type) && text[type][here]['cues'].indexOf(d.index) > -1;
                                    return (chosen ? true : null);
                                })
                                .text(function(d) {return(d.cw); })
                                .append("input").attr("type", "checkbox")
                                .attr("name", "cues")
                                .attr("autocomplete", "off")
                                .attr("value", function(d) {return (d.index); });
                            }

                        });

                // Control of results when the 'cues' change
                $(document).on("change", "input[name='cues']", function(event){
                    var analized = d3.select(this.parentNode.parentNode.parentNode.parentNode.parentNode).attr("token_id");
                    var answer = d3.select(this).attr('value');
                    
                    var cues_list = text[type][analized]['cues'];
                    if (cues_list.indexOf('none') == 0) {cues_list.splice(0, 1); }

                    if (cues_list.indexOf(answer) === -1) {
                        cues_list.push(answer);
                    } else { //if you are unclicking
                        cues_list.splice(cues_list.indexOf(answer), 1);
                    }
                    console.log(text[type][analized]);
                    
                    if (cues_list.length == 1) {AnnounceAchievement();}
                    updateTargetColor();
                    displayReminder();
                    saveInLS();
                });

                // FIRST we add the reminder to add cues if the sense is annotated
                reminder = conc.append('div')
                .attr('class', 'alert alert-warning text-center')
                .attr('role', 'alert')
                .html('Click on the words to select the cues or click <a href="#" id="no-cues-selected" class="alert-link">here</a> if there are none.');
                
                displayReminder(); // displays the reminder as must

                conc.select("#no-cues-selected").on("click", function(d){
                    text[type][d.id]['cues'] = ['none'];
                    displayReminder();
                    updateTargetColor();
                });
                // FIFTH we add an option of comments, although there is no control here since it is not compulsory

                conc.append("hr");
                conc.append("p").html('<i class="fas fa-check-circle text-muted"></i>  Any observations about this concordance?')

                inputtext = conc.append("div").attr("class", "row")
                .append("div").attr("class", "col")
                .attr("token_id", function(d) {return (d.id); });

                inputtext.append("div").append("input")
                .attr("class", "form-control")
                .attr("disabled", function() {
                    var here = d3.select(this.parentNode.parentNode).attr("token_id");
                    return (is_annotated(here, type) ? null : true);
                })
                .attr("id", function(d) {return(d.id + "_comment"); })
                .attr("name", "comments")
                .attr("placeholder", "No comments")
                .attr("aria-label", "Comments");

                // control when comments change
                $(document).on('change', 'input[name="comments"]', function(event) {
                    var analized = d3.select(this.parentNode.parentNode).attr("token_id");
                    var answer = d3.select(this).property('value');
                    if (text[type][analized] == undefined) {
                        window.alert("You have to assign a sense first!");
                    } else {
                        text[type][analized]['comments'] = answer;
                    }
                });

                // FINALLY we add 'previous' and 'next' buttons

                buttons = d3.select("#annotation").append("div")
                .attr("class", "row justify-content-sm-center")
                .append("div").attr("class", "col-sm-auto")
                .append("div").attr("class", "btn-group mt-2");
                
                buttons.append("button") // PREVIOUS
                .attr("type", "button")
                .attr("class", "btn shadow-sm btn-secondary")
                .text("Previous")
                .on("click", function() {
                    viewing > 0 ? viewing -= 1 : viewing = toClassify.length-1;
                    displayConc();
                });

                buttons.append("button") // NEXT
                .attr("type", "button")
                .attr("class", "btn shadow-sm btn-secondary")
                .text("Next")
                .on("click", function() {
                    viewing < toClassify.length-1 ? viewing += 1 : viewing = 0;
                    displayConc();
                });
                
                // ==============================================================================================================
                // SOME FUNCTIONS
                
                // Update color of target item in the overview concordance
                function updateTargetColor(t) {
                    d3.select("#overview").selectAll("p.text-sm-center")
                    .style("color", function(d) {
                        if (!is_annotated(d.id, type)) {
                            return('#000000');
                        } else if (!(has_cues(d.id, type) && has_conf(d.id, type))) {
                            return('#ef8a62');
                        } else {return("#4daf4a")}
                    });
                }

                // Update display of reminder to annotate cues
                function displayReminder() {
                    reminder.style("display", function(d) {
                        var here = d3.select(this.parentNode).attr("token_id");
                        return (is_annotated(here, type) && text[type][here]['cues'].length == 0 ? 'block' : 'none');
                    });
                }

                // update display of ocncordances
                function displayConc() {
                    conc.style('display', function(d) {
                        return(toClassify.indexOf(d.id) == viewing ? 'block' : 'none');
                    });
                }

                // Check if all the tokens of a type have been assigned with senses
                function all_senses(t) {return (d3.keys(text[t]).length == this_user['tokens'][t].length);}
                
                // Check if a particular token has been annotated
                function is_annotated(token_id, t) {
                    return (d3.keys(text[t]).indexOf(token_id) > -1);
                }

                // Check if a particular token has been assigned with cues
                function has_cues(token_id, t) {
                    return (text[t][token_id]['cues'].length > 0);
                }

                // Check if a particular token has been assigned with confidence
                function has_conf(token_id, t) {
                    return (d3.keys(text[t][token_id]).indexOf('confidence') > -1);
                }

                // Check status of a type (all annotated, all senses but not all extras, or not all senses)
                function CheckAchievements(t) {
                    var goal = this_user['tokens'][t];
                    var annotated_tokens = goal.filter(function(d) {return (is_annotated(d, t)); });
                    var tokens_with_cues = goal.filter(function(d) {return (has_cues(d, t)); });
                    var tokens_with_conf = goal.filter(function(d) {return (has_conf(d, t)); });

                    if (annotated_tokens.length == goal.length) {
                        if (tokens_with_cues.length == tokens_with_conf.length == goal.length) {
                            return('done'); // Has everything
                        } else {
                            return('halfdone'); // Has all senses but not all cues and all confidence values
                        }
                    } else {
                        return('notdone'); // Does not have all senses
                    }
                }
                
                // Fire an alert when a type is finished
                function AnnounceAchievement() {        
                    var congratulations = ["Well done!", "Awesome!", "Great!",
                    "Proficiat!", "Indrukwekkend!"];
                    var encouragement = ["Keep it up!", "Almost there!", "Great job!"]

                    if (all_senses(type)) {
                        var status = CheckAchievements(type);
                        var message, congrats;

                        if (status == 'done') {
                            congrats = congratulations;
                            var full_types = this_types.filter(function(d) {
                                return (CheckAchievements(d) == 'done');
                            });
                            if (full_types.length == this_types.length) {
                                message = "You have annotated everything, hartelijk bedankt!"
                            } else {
                                message = "You finished annotating <em>" + type + "</em>, thank you!"
                            }
                        } else if (status == 'halfdone') {
                            congrats = encouragement;
                            message = "You are almost done with <em>" + type + "</em>!"
                        }

                        Swal.fire({
                            title: congrats[Math.floor(Math.random()* congrats.length)],
                            html: message,
                            type: "success"
                        });
                    }
                }
            });
}

         // Warn the user if they leave without downloading
         window.onbeforeunload = function(){
            if (saved != JSON.stringify(text)) {
                return("No please No!!");
            } else {
                return;
            }
        };

        function saveInLS() { // check if storage is available and store
            if (typeof(Storage) !== "undefined") {
                localStorage.setItem("annotations-" + text['user'], JSON.stringify(text));
            }
        }

        
    </script>
</body>
</html>